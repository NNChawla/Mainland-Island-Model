counter <- counter + 1
}
if(!predator.first)
web.list <- cbind(web.list[,2], web.list[,1])
web.list
}
## First, source the standard food web functions file, or paste it all into R
source("standard.food.web.functions.r")
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.1   ## set connectance
N = 4     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
random.webs <- Random.model(S, L, N)
cascade.webs <- Cascade.model(S, L, N)
niche.webs <- Niche.model(S, L, N)
## plot the webs
par(mar=c(2,2,2,2))
layout(matrix(1:4, 2, 2), respect=T)
for(i in 1:4){
Plot.matrix(random.webs[[i]])
box()
}
for(i in 1:4){
Plot.matrix(cascade.webs[[i]])
box()
}
for(i in 1:4){
Plot.matrix(niche.webs[[i]])
box()
}
## get the structural properties
random.structure <- Get.web.stats(random.webs)
cascade.structure <- Get.web.stats(cascade.webs)
niche.structure <- Get.web.stats(niche.webs)
## some histograms of diet similarity, for example
par(mar=c(5,4,4,2))
prop <- "Maxsim"
prop.range <- range(c(random.structure[,prop],
cascade.structure[,prop],
niche.structure[,prop]))
prop.bins <- seq(prop.range[1], prop.range[2], length=10)
layout(matrix(1:3, 3, 1), respect=T)
hist(random.structure[,prop], main="Random", xlab=prop, breaks=prop.bins)
hist(cascade.structure[,prop], main="Cascade", xlab=prop, breaks=prop.bins)
hist(niche.structure[,prop], main="Niche", xlab=prop, breaks=prop.bins)
## Big differences between models!
library(deSolve)
library(lattice)
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.2   ## set connectance
N = 1     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
f
communities <- rep(list(vector("list", S)), S)
for(rowN in seq(1, 40)) {
for(colN in seq(1, 40)) {
xxx <- Cascade.model(S, L, N)
# par(mfrow = c(1,2))
# Plot.matrix(xxx)
# box()
# Number of Species
n <- S
r <- runif(n, -1,1)
s <- runif(n, 1,1)
g <- runif(n)
# a <- matrix(runif(n*n, 0, 0.1),nrow=n)
a <- xxx * matrix(runif(n*n, 0,1),nrow=n)
diag(a) <- rep(0,n)
# init.x <- rep(1, n)
init.x <- runif(n)
mougi_model <- function(t,x,parms){
dx <- x * (r - s*x + g * (a %*% x) - (t(a) %*% x))
list(dx)
}
n.integrate <- function(time=time, init.x= init.x, model=model){
t.out <- seq(time$start,time$end,length=time$steps)
as.data.frame(lsoda(init.x, t.out, model, parms = parms))
}
# Integration window
time <- list(start = 0, end = 100, steps = 100)
# dummy variable for lvm() function defined above
parms <- c(0) ### dummy variable (can have any numerical value)
out <- n.integrate(time, init.x, model = mougi_model)
communities[[rowN]][[colN]] <- out
# plot(out[,1], out[,2], type='l', ylim = c(0, max(out[,2:ncol(out)])), lwd = 2)
# for (i in 3:ncol(out)){
#  points(out[,1], out[,i], type='l', col = i-1, lwd = 2 )
# }
#
sum(out[nrow(out),2:n] > 10^-5) / n
}
}
communities
View(communities)
View(communities)
View(communities)
communities[[2]]
library(deSolve)
library(lattice)
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.2   ## set connectance
N = 1     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
communities <- rep(list(vector("list", S)), S)
averages <- rep(list(vector("list", S)), S)
for(rowN in seq(1, 40)) {
for(colN in seq(1, 40)) {
xxx <- Cascade.model(S, L, N)
# par(mfrow = c(1,2))
# Plot.matrix(xxx)
# box()
# Number of Species
n <- S
r <- runif(n, -1,1)
s <- runif(n, 1,1)
g <- runif(n)
# a <- matrix(runif(n*n, 0, 0.1),nrow=n)
a <- xxx * matrix(runif(n*n, 0,1),nrow=n)
diag(a) <- rep(0,n)
# init.x <- rep(1, n)
init.x <- runif(n)
mougi_model <- function(t,x,parms){
dx <- x * (r - s*x + g * (a %*% x) - (t(a) %*% x))
list(dx)
}
n.integrate <- function(time=time, init.x= init.x, model=model){
t.out <- seq(time$start,time$end,length=time$steps)
as.data.frame(lsoda(init.x, t.out, model, parms = parms))
}
# Integration window
time <- list(start = 0, end = 100, steps = 100)
# dummy variable for lvm() function defined above
parms <- c(0) ### dummy variable (can have any numerical value)
out <- n.integrate(time, init.x, model = mougi_model)
communities[[rowN]][[colN]] <- out
# plot(out[,1], out[,2], type='l', ylim = c(0, max(out[,2:ncol(out)])), lwd = 2)
# for (i in 3:ncol(out)){
#  points(out[,1], out[,i], type='l', col = i-1, lwd = 2 )
# }
#
averages[[rowN]][[colN]] <- sum(out[nrow(out),2:n] > 10^-5) / n
}
}
View(averages)
averages[[1]]
averages[[40]][[1]]
averages[[40]][1]
averages[[1]]
averages[[1]][[40]]
class(averages[[1]][[40]])
typeof(averages[[1]][[40]])
?"numeric"
averages[[1]][[40]] <- (data.frame(40, 40), 3)
averages[[1]][[40]] <- (data.frame(40, 40), 3)
averages[[1]][[40]].append(40)
averages[[1]][[40]]
?"sum"
out[nrow(out), 2:n]
out[nrow(out)]
out[nrow(out), 2:N]
out[nrow(out), 2:n]
out[nrow(out), 2:n] > 10^-5)
sum(out[nrow(out), 2:n] > 10^-5)
sum(out[nrow(out), 2:n] > 10^-5)/n
out[nrow(out)]
nrow(out)
n
out[nrow(out), 2:n+1]
1:4
1:4
2:n
out[nrow(out), 2:n]
out[100,1:40]
out[100,2:41]
dim(out)
View(out)
library(deSolve)
library(lattice)
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.2   ## set connectance
N = 1     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
communities <- rep(list(vector("list", S)), S)
averages <- rep(list(vector("list", S)), S)
for(rowN in seq(1, 40)) {
for(colN in seq(1, 40)) {
xxx <- Cascade.model(S, L, N)
# par(mfrow = c(1,2))
# Plot.matrix(xxx)
# box()
# Number of Species
n <- S
r <- runif(n, -1,1)
s <- runif(n, 1,1)
g <- runif(n)
# a <- matrix(runif(n*n, 0, 0.1),nrow=n)
a <- xxx * matrix(runif(n*n, 0,1),nrow=n)
diag(a) <- rep(0,n)
# init.x <- rep(1, n)
init.x <- runif(n)
mougi_model <- function(t,x,parms){
dx <- x * (r - s*x + g * (a %*% x) - (t(a) %*% x))
list(dx)
}
n.integrate <- function(time=time, init.x= init.x, model=model){
t.out <- seq(time$start,time$end,length=time$steps)
as.data.frame(lsoda(init.x, t.out, model, parms = parms))
}
# Integration window
time <- list(start = 0, end = 100, steps = 100)
# dummy variable for lvm() function defined above
parms <- c(0) ### dummy variable (can have any numerical value)
out <- n.integrate(time, init.x, model = mougi_model)
communities[[rowN]][[colN]] <- out
# plot(out[,1], out[,2], type='l', ylim = c(0, max(out[,2:ncol(out)])), lwd = 2)
# for (i in 3:ncol(out)){
#  points(out[,1], out[,i], type='l', col = i-1, lwd = 2 )
# }
#
averages[[rowN]][[colN]] <- sum(out[nrow(out),2:n+1] > 10^-5) / n+1
}
}
averages[[1]]
library(deSolve)
library(lattice)
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.2   ## set connectance
N = 1     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
communities <- rep(list(vector("list", S)), S)
averages <- rep(list(vector("list", S)), S)
for(rowN in seq(1, 40)) {
for(colN in seq(1, 40)) {
xxx <- Cascade.model(S, L, N)
# par(mfrow = c(1,2))
# Plot.matrix(xxx)
# box()
# Number of Species
n <- S
r <- runif(n, -1,1)
s <- runif(n, 1,1)
g <- runif(n)
# a <- matrix(runif(n*n, 0, 0.1),nrow=n)
a <- xxx * matrix(runif(n*n, 0,1),nrow=n)
diag(a) <- rep(0,n)
# init.x <- rep(1, n)
init.x <- runif(n)
mougi_model <- function(t,x,parms){
dx <- x * (r - s*x + g * (a %*% x) - (t(a) %*% x))
list(dx)
}
n.integrate <- function(time=time, init.x= init.x, model=model){
t.out <- seq(time$start,time$end,length=time$steps)
as.data.frame(lsoda(init.x, t.out, model, parms = parms))
}
# Integration window
time <- list(start = 0, end = 100, steps = 100)
# dummy variable for lvm() function defined above
parms <- c(0) ### dummy variable (can have any numerical value)
out <- n.integrate(time, init.x, model = mougi_model)
communities[[rowN]][[colN]] <- out
# plot(out[,1], out[,2], type='l', ylim = c(0, max(out[,2:ncol(out)])), lwd = 2)
# for (i in 3:ncol(out)){
#  points(out[,1], out[,i], type='l', col = i-1, lwd = 2 )
# }
#
averages[[rowN]][[colN]] <- sum(out[nrow(out),2:n] > 10^-5) / n
}
}
averages[[1]]
out
sum(out[100, 2:40])
sum(out[100, 2:40])/40
sum(out[100, 2:40] > 10^-5)/40
mean
?"mean"
c(0:10, 50)
mean(c(0:10, 50))
c(mean(c(0:10, 50)), mean(c(0:10, 50), trim = 0.10))
mean(0:10)
mean(c(0:10))
mean(1:10)
mean(c(4, 4, 1))
mean(c(4, 4, 1), 4)
mean(c(4, 4, 1), 1)
mean(c(4, 4, 1), 2)
mean(c(4, 4, 1), trim = 1)
mean(c(4, 4, 1), trim = 4)
mean(c(4, 4, 1), trim = 3)
mean(c(4, 4, 1), trim = 2)
mean(c(4, 4, 1), trim = 5)
mean(c(4 , 3, 2, 1))
mean(c(4 , 3, 2, 1), trim = 1)
mean(c(4 , 3, 2, 1), trim = 2)
mean(c(4 , 3, 2, 1), trim = 3)
mean(c(4 , 3, 2, 1), trim = 4)
mean(c(4 , 3, 2, 1), trim = 4.0)
mean(c(4 , 3, 2, 1), trim = 0.1)
mean(c(4 , 3, 2, 1), trim = 0.4)
mean(c(4 , 3, 2, 1), trim = 0.5)
mean(c(4 , 3, 2, 1), trim = 0)
mean(c(4 , 3, 2, 1), trim = 0.2)
mean(c(4 , 3, 2, 1), trim = 0.2)
c(1, 2, 3) > 2
c(1, 2, 3) > 1
/1
(c(1, 2, 3) > 1 ) /4
out
communities[[40][[40]]]
communities[[40][[40]]
communities[[40]][[4]]
communities[[40]][[40]]
out
communities[[40]][[40]]
sum(out[nrow(out),2:n] > 10^-5) / n
mean(out[nrow(out), 2:n] > 10^-5)
?"sum"
library(deSolve)
library(lattice)
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.2   ## set connectance
N = 1     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
communities <- rep(list(vector("list", S)), S)
meanStabilities <- rep(list(vector("list", S)), S)
for(rowN in seq(1, 40)) {
for(colN in seq(1, 40)) {
xxx <- Cascade.model(S, L, N)
# par(mfrow = c(1,2))
# Plot.matrix(xxx)
# box()
# Number of Species
n <- S
r <- runif(n, -1,1)
s <- runif(n, 1,1)
g <- runif(n)
# a <- matrix(runif(n*n, 0, 0.1),nrow=n)
a <- xxx * matrix(runif(n*n, 0,1),nrow=n)
diag(a) <- rep(0,n)
# init.x <- rep(1, n)
init.x <- runif(n)
mougi_model <- function(t,x,parms){
dx <- x * (r - s*x + g * (a %*% x) - (t(a) %*% x))
list(dx)
}
n.integrate <- function(time=time, init.x= init.x, model=model){
t.out <- seq(time$start,time$end,length=time$steps)
as.data.frame(lsoda(init.x, t.out, model, parms = parms))
}
# Integration window
time <- list(start = 0, end = 100, steps = 100)
# dummy variable for lvm() function defined above
parms <- c(0) ### dummy variable (can have any numerical value)
out <- n.integrate(time, init.x, model = mougi_model)
communities[[rowN]][[colN]] <- out
# plot(out[,1], out[,2], type='l', ylim = c(0, max(out[,2:ncol(out)])), lwd = 2)
# for (i in 3:ncol(out)){
#  points(out[,1], out[,i], type='l', col = i-1, lwd = 2 )
# }
#
meanStabilities[[rowN]][[colN]] <- mean(out[nrow(out),2:n] > 10^-5)
}
}
averages[[1]]
averages[[40]][[40]]
out
sum(out[nrow(out),2:n] > 10^-5) / n
out
communities[[40]][[40]]
averages[[40]][[40]]
meanStabilities[[40]][[40]]
out
communities[[40]][[40]]
meanStabilities[[40]][[40]]
sum(out[nrow(out),2:n] > 10^-5) / n
del aveerages
del averages
delete averages
sd
mean
sd
sd(1:10)
1:10
sd(1:100)
library(deSolve)
library(lattice)
## make some random, cascade, and niche food webs
S = 40     ## set species richness
C = 0.2   ## set connectance
N = 1     ## set the number of replicate webs to make
L = S^2*C  ## calculate number of links from S and C
communities <- rep(list(vector("list", S)), S)
meanStabilities <- rep(list(vector("list", S)), S)
stdDevs <- rep(list(vector("list", S)), S)
for(rowN in seq(1, 40)) {
for(colN in seq(1, 40)) {
xxx <- Cascade.model(S, L, N)
# par(mfrow = c(1,2))
# Plot.matrix(xxx)
# box()
# Number of Species
n <- S
r <- runif(n, -1,1)
s <- runif(n, 1,1)
g <- runif(n)
# a <- matrix(runif(n*n, 0, 0.1),nrow=n)
a <- xxx * matrix(runif(n*n, 0,1),nrow=n)
diag(a) <- rep(0,n)
# init.x <- rep(1, n)
init.x <- runif(n)
mougi_model <- function(t,x,parms){
dx <- x * (r - s*x + g * (a %*% x) - (t(a) %*% x))
list(dx)
}
n.integrate <- function(time=time, init.x= init.x, model=model){
t.out <- seq(time$start,time$end,length=time$steps)
as.data.frame(lsoda(init.x, t.out, model, parms = parms))
}
# Integration window
time <- list(start = 0, end = 100, steps = 100)
# dummy variable for lvm() function defined above
parms <- c(0) ### dummy variable (can have any numerical value)
out <- n.integrate(time, init.x, model = mougi_model)
communities[[rowN]][[colN]] <- out
# plot(out[,1], out[,2], type='l', ylim = c(0, max(out[,2:ncol(out)])), lwd = 2)
# for (i in 3:ncol(out)){
#  points(out[,1], out[,i], type='l', col = i-1, lwd = 2 )
# }
#
meanStabilities[[rowN]][[colN]] <- mean(out[nrow(out),2:n] > 10^-5)
stdDevs[[rowN]][[colN]] <- sd(out[nrow(out),2:n] > 10^-5)
}
}
View(stdDevs)
View(stdDevs)
stdDevs[[9]]
install.packages("tidyverse")
library(tidyverse)
mpg
ggplot(data = mpg)
View(communities)
View(communities)
View(communities)
ggplot(communities[[40]][[40]]) +
geom_point(aes(x = time, y = communities[[40]][[40]][[nrow(communities[[40]][[40]]), 2:n]]))
ggplot(out) +
geom_point()
out
names(out)
libarary(reshape2)
install.packages(reshape2)
?"melt"
out
as.tibble(out)
out[[2:n]]
out[[2]]
out[[100, 2:n]]
out[[nrow(out), 2:n]]
out[nrow(out), 2:n]
ggplot(data = out) +
geom_point(mapping = aes = (x = time, y = 1))
ggplot(data = out) +
geom_point(mapping = aes = (x= time, y = 1))
ggplot(data = out) +
geom_point(mapping = aes(x= time, y = 1))
as.tribble(out)
as.tibble(out)
ggplot(data = out) +
geom_point(mapping = aes(x= time, y = 2))
geom_point(mapping = aes(x= time, y = "1"))
ggplot(data = out) +
geom_point(mapping = aes(x= time, y = "1"))
melt(out)
unite(out)
unite(as.tibble(out))
head(unite(as.tibble(out)))
out <- as.tibble(out)
out
unite(as.tibble(out), id.vars="time")
install.packages("reshape2")
library("reshape2")
melt(out)
melt(out, id.vars="time")
melt(out)
a <- melt(out)
a
ggplot(data = a) +
geom_point(mapping=aes(x=time, y=value))
ggplot(data = a) +
geom_point(mapping=aes(x=time, y=variable))
melt(out, id.vars = "time")
a <- melt(out, id.vars = "time")
ggplot(data = a) +
geom_point(mapping=aes(x=time, y=value))
ggplot(data = a) +
geom_point(mapping=aes(x=time, y=value, color=variable))
ggplot(data = a) +
geom_smoooth(mapping=aes(x=time, y=value, color=variable))
ggplot(data = a) +
geom_smooth(mapping=aes(x=time, y=value, color=variable))
ggplot(data = a) +
geom_point(mapping=aes(x=time, y=value, color=variable))
b <- meanStabilities[[40]][[40]]
b
ggplot(data = a) +
geom_smooth(mapping=aes(x=time, y=value, color=variable), se=FALSE, method = lm)
